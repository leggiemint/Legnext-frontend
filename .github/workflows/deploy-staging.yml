# Staging Deployment Workflow - Develop Branch
name: ğŸ§ª Staging Deployment

on:
  push:
    branches: [ develop ]
  pull_request:
    branches: [ main ]

env:
  DOCKER_IMAGE: legnext-midjourney-api-staging
  NODE_VERSION: '18'
  PNPM_VERSION: '8'

jobs:
  # Job 1: Setup Dependencies (Shared)
  setup:
    name: ğŸ› ï¸ Setup Dependencies
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate cache key
        id: cache-key
        run: |
          echo "key=node-${{ env.NODE_VERSION }}-pnpm-${{ env.PNPM_VERSION }}-${{ hashFiles('pnpm-lock.yaml') }}" >> $GITHUB_OUTPUT

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Cache node_modules
        uses: actions/cache@v3
        id: cache-deps
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ steps.cache-key.outputs.key }}
          restore-keys: |
            node-${{ env.NODE_VERSION }}-pnpm-${{ env.PNPM_VERSION }}-

      - name: Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm prisma generate
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          DIRECT_URL: ${{ secrets.STAGING_DIRECT_URL }}

      - name: Cache Prisma Client
        uses: actions/cache@v3
        with:
          path: node_modules/.prisma
          key: prisma-${{ hashFiles('prisma/schema.prisma') }}

  # Job 2: Code Quality Checks
  quality-checks:
    name: ğŸ” Code Quality Checks
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Restore dependencies cache
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}
          restore-keys: |
            node-${{ env.NODE_VERSION }}-pnpm-${{ env.PNPM_VERSION }}-

      - name: Restore Prisma Client
        uses: actions/cache@v3
        with:
          path: node_modules/.prisma
          key: prisma-${{ hashFiles('prisma/schema.prisma') }}

      - name: TypeScript Check
        run: pnpm run lint

      - name: Security Audit
        run: pnpm audit --audit-level high
        continue-on-error: true  # Don't fail staging for moderate security issues

      - name: Check Prisma Schema
        run: pnpm prisma validate
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          DIRECT_URL: ${{ secrets.STAGING_DIRECT_URL }}

  # Job 3: Build and Test
  build-and-test:
    name: ğŸ—ï¸ Build & Test
    runs-on: ubuntu-latest
    needs: [setup]
    # Note: Can run in parallel with quality-checks for faster pipeline
    outputs:
      build-cache-key: ${{ steps.build-cache.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Restore dependencies cache
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}

      - name: Restore Prisma Client
        uses: actions/cache@v3
        with:
          path: node_modules/.prisma
          key: prisma-${{ hashFiles('prisma/schema.prisma') }}

      - name: Generate build cache key
        id: build-cache
        run: |
          echo "key=build-${{ github.sha }}-${{ hashFiles('**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx', 'next.config.js', 'tailwind.config.js') }}" >> $GITHUB_OUTPUT

      - name: Cache Next.js build
        uses: actions/cache@v3
        with:
          path: |
            .next/cache
          key: ${{ steps.build-cache.outputs.key }}
          restore-keys: |
            build-${{ github.sha }}-
            build-

      - name: Build application
        run: pnpm build
        env:
          # Build-time environment variables for staging
          NEXTAUTH_URL: ${{ secrets.STAGING_NEXTAUTH_URL }}
          NEXTAUTH_SECRET: ${{ secrets.STAGING_NEXTAUTH_SECRET }}
          NEXT_PUBLIC_STRIPE_PRO_PRICE_ID: ${{ secrets.NEXT_PUBLIC_STAGING_STRIPE_PRO_PRICE_ID }}
          # Backend API é…ç½®
          BACKEND_API_URL: ${{ secrets.STAGING_BACKEND_API_URL }}
          BACKEND_API_KEY: ${{ secrets.STAGING_BACKEND_API_KEY }}
          # æ•°æ®åº“é…ç½®ï¼ˆæ„å»ºæ—¶ä¹Ÿéœ€è¦ï¼‰
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          DIRECT_URL: ${{ secrets.STAGING_DIRECT_URL }}
          # å…¶ä»–å¯èƒ½éœ€è¦çš„ç¯å¢ƒå˜é‡
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          # R2 é…ç½®
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          R2_PUBLIC_URL: ${{ secrets.R2_PUBLIC_URL }}
          # Google OAuth
          GOOGLE_ID: ${{ secrets.GOOGLE_ID }}
          GOOGLE_SECRET: ${{ secrets.GOOGLE_SECRET }}

      - name: Run tests (if available)
        run: |
          if [ -f "package.json" ] && grep -q '"test"' package.json; then
            pnpm test
          else
            echo "No tests found, skipping test execution"
          fi
        continue-on-error: true

  # Job 4: Docker Build (Staging)
  docker-build:
    name: ğŸ³ Docker Build
    runs-on: ubuntu-latest
    needs: [build-and-test, quality-checks]
    # Wait for both build and quality checks to complete
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}
          tags: |
            type=raw,value=staging-latest
            type=sha,prefix=staging-
          flavor: |
            latest=false

      - name: Debug metadata output
        run: |
          echo "ğŸ” Metadata outputs:"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Labels: ${{ steps.meta.outputs.labels }}"
          echo "JSON: ${{ steps.meta.outputs.json }}"

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}
            DIRECT_URL=${{ secrets.STAGING_DIRECT_URL }}
            BACKEND_API_KEY=${{ secrets.STAGING_BACKEND_API_KEY }}
            STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
            RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
            NEXTAUTH_SECRET=${{ secrets.STAGING_NEXTAUTH_SECRET }}

  # Job 5: Deploy to Staging
  deploy-staging:
    name: ğŸš¢ Deploy to Staging
    runs-on: ubuntu-latest
    needs: docker-build
    environment: staging
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')
    steps:
      - name: Checkout deployment scripts
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.STAGING_VPS_SSH_KEY }}

      - name: Deploy to Staging VPS (Inline Script)
        run: |
          # Use staging-latest tag for deployment (always prefer this stable tag)
          STAGING_LATEST_TAG="${{ secrets.DOCKER_USERNAME }}/${{ env.DOCKER_IMAGE }}:staging-latest"

          echo "ğŸ” Available tags: ${{ needs.docker-build.outputs.image-tag }}"
          echo "ğŸ¯ Using deployment tag: $STAGING_LATEST_TAG"

          IMAGE_TAG="$STAGING_LATEST_TAG"

          # Create deployment script
          cat > /tmp/staging-deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e

          echo "ğŸš€ å¼€å§‹ ClawCloud VPS æµ‹è¯•ç¯å¢ƒéƒ¨ç½²..."
          echo "ğŸ” è°ƒè¯•ä¿¡æ¯: IMAGE_TAG = $1"

          IMAGE_TAG="$1"

          # 1. è¿›å…¥é¡¹ç›®ç›®å½•
          cd /opt/legnext-staging

          # 2. æ£€æŸ¥å¹¶å¤‡ä»½å½“å‰é…ç½®
          echo "ğŸ“ å½“å‰ç›®å½•å†…å®¹:"
          ls -la

          if [ -f docker-compose.yml ]; then
              echo "ğŸ“‹ å¤‡ä»½ docker-compose.yml"
              cp docker-compose.yml docker-compose.yml.backup
              echo "ğŸ” å½“å‰ docker-compose.yml å†…å®¹:"
              cat docker-compose.yml
          else
              echo "âŒ docker-compose.yml æ–‡ä»¶ä¸å­˜åœ¨"
              exit 1
          fi

          # 3. åœæ­¢ç°æœ‰æœåŠ¡
          echo "â¹ï¸ åœæ­¢ç°æœ‰æœåŠ¡..."
          docker-compose down || true

          # 4. æ‹‰å–æœ€æ–°é•œåƒ
          echo "ğŸ“¥ æ‹‰å–æœ€æ–°é•œåƒ: $IMAGE_TAG"
          if [ -z "$IMAGE_TAG" ]; then
              echo "âŒ IMAGE_TAG ä¸ºç©ºï¼Œæ— æ³•æ‹‰å–é•œåƒ"
              exit 1
          fi
          docker pull "$IMAGE_TAG"

          # 5. æ›´æ–° docker-compose.yml ä¸­çš„é•œåƒæ ‡ç­¾
          echo "ğŸ”„ æ›´æ–° docker-compose.yml ä¸­çš„é•œåƒæ ‡ç­¾..."

          # æ›´æ–° app æœåŠ¡çš„é•œåƒ
          sed -i "/services:/,/app:/{/image:/s|image:.*|image: $IMAGE_TAG|}" docker-compose.yml

          # å¦‚æœ Redis é•œåƒä¹Ÿæ˜¯ç©ºçš„ï¼Œè®¾ç½®é»˜è®¤å€¼
          sed -i "/redis:/,/container_name:/{/image:.*\$/s|image:.*|image: redis:7-alpine|}" docker-compose.yml

          echo "âœ… æ›´æ–°åçš„ docker-compose.yml:"
          cat docker-compose.yml

          # 6. æ¸…ç†æ—§é•œåƒå’Œå®¹å™¨
          echo "ğŸ§¹ æ¸…ç†æ—§èµ„æº..."
          docker system prune -f

          # 7. å¯åŠ¨æœåŠ¡
          echo "ğŸš€ å¯åŠ¨æœåŠ¡..."
          docker-compose up -d

          # 8. ç­‰å¾…æœåŠ¡å¯åŠ¨
          echo "â³ ç­‰å¾…æœåŠ¡å¯åŠ¨..."
          sleep 15

          # 9. å¥åº·æ£€æŸ¥
          echo "ğŸ¥ æ‰§è¡Œå¥åº·æ£€æŸ¥..."
          for i in {1..10}; do
              if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                  echo "âœ… ClawCloud æµ‹è¯•ç¯å¢ƒéƒ¨ç½²æˆåŠŸï¼"

                  # 10. é‡æ–°åŠ è½½Nginx
                  sudo systemctl reload nginx

                  # 11. æ˜¾ç¤ºæœåŠ¡çŠ¶æ€
                  echo "ğŸ“Š æœåŠ¡çŠ¶æ€:"
                  docker-compose ps

                  echo "ğŸ‰ éƒ¨ç½²å®Œæˆï¼è®¿é—®åœ°å€: https://staging-a93116.legnext.ai"
                  exit 0
              fi
              echo "â³ å¥åº·æ£€æŸ¥å°è¯• $i/10..."
              sleep 3
          done

          echo "âŒ å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œéƒ¨ç½²å¯èƒ½æœ‰é—®é¢˜"
          echo "ğŸ“ æŸ¥çœ‹æ—¥å¿—:"
          docker-compose logs --tail=50

          exit 1
          DEPLOY_SCRIPT

          # Transfer and execute the script
          scp -o StrictHostKeyChecking=no /tmp/staging-deploy.sh ${{ secrets.STAGING_VPS_USERNAME }}@${{ secrets.STAGING_VPS_HOST }}:/tmp/
          ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_VPS_USERNAME }}@${{ secrets.STAGING_VPS_HOST }} "chmod +x /tmp/staging-deploy.sh && /tmp/staging-deploy.sh '$IMAGE_TAG'"

  # Job 6: Database Migration (Staging)
  staging-db-migration:
    name: ğŸ—„ï¸ Staging DB Migration
    runs-on: ubuntu-latest
    needs: [setup, deploy-staging]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Restore dependencies cache
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.pnpm-store
          key: ${{ needs.setup.outputs.cache-key }}

      - name: Install Prisma CLI only (if cache miss)
        run: |
          if [ ! -d "node_modules" ] || [ ! -d "node_modules/.bin" ]; then
            pnpm add -D prisma
          fi

      - name: Run staging database migrations
        run: pnpm prisma migrate deploy
        env:
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          DIRECT_URL: ${{ secrets.STAGING_DIRECT_URL }}
        continue-on-error: true  # Don't fail if migration has issues in staging

  # Job 7: Staging Health Check
  staging-health-check:
    name: ğŸ¥ Staging Health Check
    runs-on: ubuntu-latest
    needs: [deploy-staging, staging-db-migration]
    if: always() && needs.deploy-staging.result == 'success'
    steps:
      - name: Wait for staging deployment
        run: sleep 20

      - name: Health check - Staging API
        run: |
          for i in {1..5}; do
            if curl -f -s -o /dev/null https://${{ secrets.STAGING_DOMAIN }}/health; then
              echo "âœ… Staging health check passed"
              exit 0
            fi
            echo "â³ Attempt $i failed, retrying..."
            sleep 5
          done
          echo "âŒ Staging health check failed"
          exit 1
        continue-on-error: true

      - name: Basic functionality test
        run: |
          # Test homepage
          if curl -f -s https://${{ secrets.STAGING_DOMAIN }}/ > /dev/null; then
            echo "âœ… Staging homepage accessible"
          else
            echo "âŒ Staging homepage not accessible"
          fi
          
          # Test API endpoints
          if curl -f -s https://${{ secrets.STAGING_DOMAIN }}/api/auth/session > /dev/null; then
            echo "âœ… Staging auth API accessible"
          else
            echo "âŒ Staging auth API not accessible"
          fi
        continue-on-error: true

  # Job 8: Performance and Security Testing
  staging-tests:
    name: ğŸ§ª Staging Integration Tests
    runs-on: ubuntu-latest
    needs: staging-health-check
    if: needs.staging-health-check.result == 'success'
    steps:
      - name: Lighthouse Performance Test
        uses: treosh/lighthouse-ci-action@v10
        with:
          urls: |
            https://${{ secrets.STAGING_DOMAIN }}
          uploadArtifacts: true
          temporaryPublicStorage: true
        continue-on-error: true

      - name: Security Headers Check
        run: |
          response=$(curl -s -I https://${{ secrets.STAGING_DOMAIN }})
          
          echo "ğŸ” Checking security headers..."
          
          if echo "$response" | grep -q "X-Frame-Options"; then
            echo "âœ… X-Frame-Options header present"
          else
            echo "âŒ X-Frame-Options header missing"
          fi
          
          if echo "$response" | grep -q "X-Content-Type-Options"; then
            echo "âœ… X-Content-Type-Options header present"
          else
            echo "âŒ X-Content-Type-Options header missing"
          fi
        continue-on-error: true

  # Job 9: PR Comment with Staging Info
  pr-comment:
    name: ğŸ“ Update PR with Staging Info
    runs-on: ubuntu-latest
    needs: [staging-health-check, staging-tests]
    if: github.event_name == 'pull_request'
    steps:
      - name: Comment PR with staging deployment info
        uses: actions/github-script@v6
        with:
          script: |
            const comment = `## ğŸ§ª Staging Deployment Status
            
            **ğŸ”— Staging URL**: https://${{ secrets.STAGING_DOMAIN }}
            **ğŸ·ï¸ Docker Image**: \`${{ needs.docker-build.outputs.image-tag }}\`
            **ğŸ¥ Health Check**: ${{ needs.staging-health-check.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }}
            **ğŸ§ª Tests**: ${{ needs.staging-tests.result == 'success' && 'âœ… Passed' || needs.staging-tests.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }}
            
            ### ğŸ§ª Test the staging environment:
            - [ ] Login/Logout functionality
            - [ ] API endpoints working
            - [ ] Payment flow (test mode)
            - [ ] Image generation functionality
            - [ ] Database operations
            
            ### ğŸ”— Quick Links:
            - [Staging Site](https://${{ secrets.STAGING_DOMAIN }})
            - [Health Check](https://${{ secrets.STAGING_DOMAIN }}/health)
            - [API Status](https://${{ secrets.STAGING_DOMAIN }}/api/auth/session)
            
            ---
            *Auto-generated from GitHub Actions workflow*
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Job 10: Slack Notification
  notify:
    name: ğŸ“¢ Notify Staging Status
    runs-on: ubuntu-latest
    needs: [deploy-staging, staging-health-check]
    if: always()
    steps:
      - name: Notify staging deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            ğŸ§ª *Staging Deployment Complete*
            
            ğŸ“‹ Branch: `${{ github.ref_name }}`
            ğŸ·ï¸ Image: `${{ needs.docker-build.outputs.image-tag }}`
            ğŸŒ URL: https://${{ secrets.STAGING_DOMAIN }}
            âœ… Health: ${{ needs.staging-health-check.result == 'success' && 'âœ… Healthy' || 'âŒ Failed' }}
            
            ${{ github.event_name == 'pull_request' && format('ğŸ”— PR: {0}', github.event.pull_request.html_url) || '' }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

  # Job 11: Cleanup Old Images
  cleanup:
    name: ğŸ§¹ Cleanup Old Images
    runs-on: ubuntu-latest
    needs: staging-health-check
    if: always()
    # Runs cleanup regardless of other job outcomes
    steps:
      - name: Cleanup old staging images on VPS
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_VPS_USERNAME }}@${{ secrets.STAGING_VPS_HOST }} << 'EOF'
            # Keep only the latest 3 staging images
            docker images --format "table {{.Repository}}:{{.Tag}} {{.CreatedAt}}" | \
            grep legnext-midjourney-api-staging | \
            sort -k2 -r | \
            tail -n +4 | \
            awk '{print $1}' | \
            xargs -r docker rmi || true
            
            echo "âœ… Cleaned up old staging images"
          EOF
        continue-on-error: true