import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import { uploadToR2 } from './r2';
import { log } from './logger';

export interface CompanyReplacement {
  oldInfo: {
    name: string;
    address: string[];
    city: string;
    country: string;
    phone?: string;
  };
  newInfo: {
    name: string;
    address: string[];
    city: string;
    country: string;
    phone?: string;
  };
}

export interface PDFProcessingOptions {
  replacements?: CompanyReplacement[];
  cacheEnabled?: boolean;
  cacheTTL?: number;
}

export class PDFProcessor {
  private static readonly CACHE_PREFIX = 'processed-invoice-';
  
  // ÈªòËÆ§ÁöÑÂÖ¨Âè∏‰ø°ÊÅØÊõøÊç¢ÈÖçÁΩÆ
  private static readonly DEFAULT_REPLACEMENTS: CompanyReplacement[] = [
    {
      oldInfo: {
        name: "New business sandbox",
        address: ["CA"],
        city: "San Francisco",
        country: "address_full_match\nHong Kong",
        phone: "+1 415-555-0199"
      },
      newInfo: {
        name: "LEGNEXT LLC",
        address: ["WORKSHOP 210, 5/F, BLK B,", "HUDSON IND CTR NO. 485 7TH AVE"],
        city: "New York, NY 10018",
        country: "United States"
      }
    },
    {
      oldInfo: {
        name: "DARK ENLIGHTENMENT LIMITED",
        address: ["‰πùÈæç", "KWUN TONG", "WORKSHOP 60, 3/F, BLK A, EAST", "SUN IND CTR NO. 16 SHING YIP ST"],
        city: "Hong Kong",
        country: "Hong Kong"
      },
      newInfo: {
        name: "LEGNEXT LLC",
        address: ["WORKSHOP 210, 5/F, BLK B,", "HUDSON IND CTR NO. 485 7TH AVE"],
        city: "New York, NY 10018",
        country: "United States"
      }
    }
  ];

  /**
   * Â§ÑÁêÜÂèëÁ•®PDFÔºåÊõøÊç¢ÂÖ¨Âè∏‰ø°ÊÅØ
   */
  async processInvoicePDF(
    invoiceId: string, 
    originalPdfUrl: string,
    options: PDFProcessingOptions = {}
  ): Promise<{ success: boolean; url?: string; error?: string }> {
    const startTime = Date.now();
    const debugId = `pdf_${invoiceId}_${startTime}`;
    
    try {
      log.info(`üîÑ Starting PDF processing`, {
        debugId,
        invoiceId,
        originalPdfUrl,
        cacheEnabled: options.cacheEnabled !== false,
        customReplacements: !!options.replacements
      });

      // Ê£ÄÊü•ÁºìÂ≠ò
      if (options.cacheEnabled !== false) {
        log.debug(`üîç Checking cache for invoice: ${invoiceId}`, { debugId });
        
        const cacheCheckStart = Date.now();
        const cachedUrl = await this.getCachedPDF(invoiceId);
        const cacheCheckTime = Date.now() - cacheCheckStart;
        
        if (cachedUrl) {
          log.info(`‚úÖ Cache hit - returning cached PDF`, {
            debugId,
            invoiceId,
            cachedUrl,
            cacheCheckTimeMs: cacheCheckTime,
            totalTimeMs: Date.now() - startTime
          });
          return { success: true, url: cachedUrl };
        } else {
          log.debug(`‚ùå Cache miss for invoice: ${invoiceId}`, {
            debugId,
            cacheCheckTimeMs: cacheCheckTime
          });
        }
      } else {
        log.debug(`‚è≠Ô∏è Cache disabled, proceeding with fresh processing`, { debugId });
      }

      // ‰∏ãËΩΩÂéüÂßãPDF
      log.debug(`üì• Starting PDF download`, { debugId, originalPdfUrl });
      const downloadStart = Date.now();
      
      const pdfBuffer = await this.downloadPDF(originalPdfUrl);
      const downloadTime = Date.now() - downloadStart;
      
      if (!pdfBuffer) {
        log.error(`‚ùå PDF download failed`, {
          debugId,
          invoiceId,
          originalPdfUrl,
          downloadTimeMs: downloadTime
        });
        return { success: false, error: 'Failed to download original PDF' };
      }

      log.info(`‚úÖ PDF downloaded successfully`, {
        debugId,
        pdfSizeBytes: pdfBuffer.length,
        downloadTimeMs: downloadTime
      });

      // Â§ÑÁêÜPDF
      log.debug(`üîÑ Starting PDF text replacement`, { debugId });
      const processingStart = Date.now();
      
      const replacements = options.replacements || PDFProcessor.DEFAULT_REPLACEMENTS;
      log.debug(`üìù Using ${replacements.length} replacement rules`, {
        debugId,
        replacements: replacements.map(r => ({
          from: r.oldInfo.name,
          to: r.newInfo.name
        }))
      });
      
      const processedPdfBuffer = await this.replacePDFText(pdfBuffer, replacements);
      const processingTime = Date.now() - processingStart;
      
      log.info(`‚úÖ PDF text replacement completed`, {
        debugId,
        originalSizeBytes: pdfBuffer.length,
        processedSizeBytes: processedPdfBuffer.length,
        processingTimeMs: processingTime
      });

      // ‰∏ä‰º†Âà∞R2
      log.debug(`‚òÅÔ∏è Starting R2 upload`, { debugId });
      const uploadStart = Date.now();
      const uploadKey = `${PDFProcessor.CACHE_PREFIX}${invoiceId}.pdf`;
      
      const uploadResult = await uploadToR2(
        uploadKey,
        processedPdfBuffer,
        'application/pdf'
      );
      const uploadTime = Date.now() - uploadStart;

      if (!uploadResult.success) {
        log.error(`‚ùå R2 upload failed`, {
          debugId,
          invoiceId,
          uploadKey,
          uploadTimeMs: uploadTime,
          error: uploadResult.error
        });
        return { success: false, error: 'Failed to upload processed PDF' };
      }

      const totalTime = Date.now() - startTime;
      log.info(`üéâ PDF processing completed successfully`, {
        debugId,
        invoiceId,
        processedUrl: uploadResult.url,
        uploadTimeMs: uploadTime,
        totalTimeMs: totalTime,
        performanceBreakdown: {
          downloadMs: downloadTime,
          processingMs: processingTime,
          uploadMs: uploadTime,
          totalMs: totalTime
        }
      });

      return { success: true, url: uploadResult.url };

    } catch (error) {
      const totalTime = Date.now() - startTime;
      log.error(`üí• PDF processing failed`, {
        debugId,
        invoiceId,
        originalPdfUrl,
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error,
        totalTimeMs: totalTime
      });
      
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error occurred' 
      };
    }
  }

  /**
   * ‰∏ãËΩΩPDFÊñá‰ª∂
   */
  private async downloadPDF(url: string): Promise<Buffer | null> {
    const maxRetries = 3;
    const retryDelay = 1000; // 1Áßí
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        
        const fetchStart = Date.now();
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'User-Agent': 'Mozilla/5.0 (compatible; LEGNEXT-PDF-Processor/1.0)',
            'Accept': 'application/pdf,*/*',
            'Accept-Language': 'en-US,en;q=0.9',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          },
          redirect: 'follow',
          // Â¢ûÂä†Ë∂ÖÊó∂Êó∂Èó¥
          signal: AbortSignal.timeout(30000) // 30ÁßíË∂ÖÊó∂
        });
        const fetchTime = Date.now() - fetchStart;
      
        // PDF‰∏ãËΩΩÂìçÂ∫îÊ£ÄÊü•
        
        if (!response.ok) {
          const errorMessage = `HTTP ${response.status}: ${response.statusText}`;
          
          // ÂØπ‰∫éÊüê‰∫õÈîôËØØÔºå‰∏çÈúÄË¶ÅÈáçËØï
          if (response.status === 404 || response.status === 403 || response.status === 401) {
            log.error(`‚ùå HTTP request failed - no retry needed`, {
              url: url.substring(0, 100) + '...',
              attempt,
              status: response.status,
              statusText: response.statusText,
              reason: 'Client error - no point in retrying'
            });
            throw new Error(errorMessage);
          }
          
          // ÂØπ‰∫éÊúçÂä°Âô®ÈîôËØØÔºåÂèØ‰ª•ÈáçËØï
          if (attempt < maxRetries && (response.status >= 500 || response.status === 429)) {
            log.warn(`‚ö†Ô∏è HTTP request failed - will retry`, {
              url: url.substring(0, 100) + '...',
              attempt,
              status: response.status,
              statusText: response.statusText,
              nextAttemptIn: retryDelay * attempt
            });
            
            await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
            continue; // ÈáçËØï
          }
          
          throw new Error(errorMessage);
        }

        // È™åËØÅÂìçÂ∫îÂÜÖÂÆπÁ±ªÂûã
        const contentType = response.headers.get('content-type');

        const bufferStart = Date.now();
        const arrayBuffer = await response.arrayBuffer();
        const bufferTime = Date.now() - bufferStart;
        const buffer = Buffer.from(arrayBuffer);
        
        // È™åËØÅPDFÊñá‰ª∂
        if (buffer.length < 100) {
          throw new Error('Downloaded file is too small to be a valid PDF');
        }
        
        // Ê£ÄÊü•PDF magic number
        const pdfHeader = buffer.toString('ascii', 0, 4);
        if (pdfHeader !== '%PDF') {
          log.warn(`‚ö†Ô∏è Downloaded file may not be a valid PDF`, {
            fileHeader: pdfHeader,
            fileSize: buffer.length
          });
        }
        
        return buffer;
        
      } catch (error) {
        const isLastAttempt = attempt === maxRetries;
        const shouldRetry = !isLastAttempt && (
          error instanceof TypeError || // ÁΩëÁªúÈîôËØØ
          (error instanceof Error && error.message.includes('timeout')) ||
          (error instanceof Error && error.message.includes('fetch failed'))
        );
        
        if (shouldRetry) {
          log.warn(`‚ö†Ô∏è PDF download failed - will retry`, {
            url: url.substring(0, 100) + '...',
            attempt,
            error: error instanceof Error ? {
              name: error.name,
              message: error.message
            } : error,
            nextAttemptIn: retryDelay * attempt
          });
          
          await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
          continue; // ÈáçËØï
        } else {
          log.error(`üí• PDF download failed (final attempt)`, {
            url: url.substring(0, 100) + '...',
            attempt,
            maxRetries,
            error: error instanceof Error ? {
              name: error.name,
              message: error.message,
              stack: error.stack
            } : error
          });
          
          return null;
        }
      }
    }
    
    // Â¶ÇÊûúÊâÄÊúâÈáçËØïÈÉΩÂ§±Ë¥•‰∫Ü
    log.error(`üí• PDF download failed after all retries`, {
      url: url.substring(0, 100) + '...',
      maxRetries,
      totalAttempts: maxRetries
    });
    
    return null;
  }

  /**
   * ÊõøÊç¢PDF‰∏≠ÁöÑÊñáÊú¨ÂÜÖÂÆπ
   */
  private async replacePDFText(
    pdfBuffer: Buffer, 
    replacements: CompanyReplacement[]
  ): Promise<Buffer> {
    try {
      log.info(`üîÑ Starting PDF text replacement`, { 
        pdfSizeBytes: pdfBuffer.length,
        replacementCount: replacements.length 
      });
      
      // Âä†ËΩΩPDFÊñáÊ°£
      const loadStart = Date.now();
      const pdfDoc = await PDFDocument.load(pdfBuffer);
      const loadTime = Date.now() - loadStart;
      
      const pages = pdfDoc.getPages();
      
      // Ëé∑ÂèñÂ≠ó‰Ωì
      const fontStart = Date.now();
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      const fontTime = Date.now() - fontStart;

      // Â§ÑÁêÜÊØè‰∏™È°µÈù¢
      const pageProcessingStart = Date.now();
      let totalReplacements = 0;
      
      for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
        const page = pages[pageIndex];
        
        for (let replIndex = 0; replIndex < replacements.length; replIndex++) {
          const replacement = replacements[replIndex];
          
          const replacementResult = await this.replaceCompanyInfoOnPage(
            page, 
            replacement, 
            font, 
            boldFont,
            pageIndex + 1
          );
          
          if (replacementResult.applied) {
            totalReplacements++;
          }
        }
      }
      
      const pageProcessingTime = Date.now() - pageProcessingStart;

      // ÁîüÊàêÊñ∞ÁöÑPDF
      const saveStart = Date.now();
      const processedPdfBytes = await pdfDoc.save();
      const saveTime = Date.now() - saveStart;
      
      const finalBuffer = Buffer.from(processedPdfBytes);
      
      log.info(`‚úÖ PDF text replacement completed`, {
        originalSizeBytes: pdfBuffer.length,
        processedSizeBytes: finalBuffer.length,
        totalReplacements,
        totalProcessingTimeMs: loadTime + fontTime + pageProcessingTime + saveTime
      });
      
      return finalBuffer;
    } catch (error) {
      log.error(`üí• PDF text replacement failed`, {
        pdfSizeBytes: pdfBuffer.length,
        replacementCount: replacements.length,
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      });
      throw error;
    }
  }

  /**
   * Âú®È°µÈù¢‰∏äÊõøÊç¢ÂÖ¨Âè∏‰ø°ÊÅØ
   */
  private async replaceCompanyInfoOnPage(
    page: any, 
    replacement: CompanyReplacement, 
    font: any, 
    boldFont: any,
    pageNumber: number
  ): Promise<{ applied: boolean; details?: any }> {
    try {
      const { width, height } = page.getSize();
      
      // ÂÖ¨Âè∏‰ø°ÊÅØÊõøÊç¢Â§ÑÁêÜ
      
      // ÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊñáÊú¨ÊõøÊç¢Á≠ñÁï•
      // Ê≥®ÊÑèÔºöpdf-lib‰∏çÁõ¥Êé•ÊîØÊåÅÊñáÊú¨ÊêúÁ¥¢ÊõøÊç¢ÔºåËøôÈáåÊàë‰ª¨ÈááÁî®Ë¶ÜÁõñÁ≠ñÁï•
      
      // ÂÅáËÆæÂÖ¨Âè∏‰ø°ÊÅØÈÄöÂ∏∏Âú®PDFÁöÑÈ°∂ÈÉ®Âå∫Âüü
      // Êàë‰ª¨Âú®ÂèØËÉΩÁöÑ‰ΩçÁΩÆÊîæÁΩÆÊñ∞ÁöÑÂÖ¨Âè∏‰ø°ÊÅØ
      
      // Ê†πÊçÆÁ≤æÁ°ÆÁöÑËã±ÂØ∏Â∞∫ÂØ∏ËÆ°ÁÆóË¶ÜÁõñÂå∫Âüü
      // PDFÊ†áÂáÜÂ∞∫ÂØ∏: 8.5 √ó 11 Ëã±ÂØ∏ = 612 √ó 792 ÁÇπ (1Ëã±ÂØ∏ = 72ÁÇπ)
      const POINTS_PER_INCH = 72;
      
      // ÂÖ¨Âè∏‰ø°ÊÅØË¶ÜÁõñÂå∫ÂüüÔºöÂÆΩ2.6Ëã±ÂØ∏ÔºåÈ´ò1.5Ëã±ÂØ∏Ôºõ‰ΩçÁΩÆÔºöx:0.23 y:1.56Ëã±ÂØ∏
      const companyInfoX = 0.23 * POINTS_PER_INCH;      // 16.56 ÁÇπ
      const companyInfoY = (11 - 1.56 - 1.5) * POINTS_PER_INCH; // PDF YËΩ¥‰ªéÂ∫ïÈÉ®ÂºÄÂßã: (11 - 1.56 - 1.5) * 72
      const companyInfoWidth = 2.6 * POINTS_PER_INCH;   // 187.2 ÁÇπ
      const companyInfoHeight = 1.5 * POINTS_PER_INCH;  // 108 ÁÇπ
      
      // ‰∏ªË¶ÜÁõñÂå∫ÂüüÂèòÈáè
      const coverRectX = companyInfoX;
      const coverRectY = companyInfoY; 
      const coverRectWidth = companyInfoWidth;
      const coverRectHeight = companyInfoHeight;
      
      // Â∫îÁî®Ë¶ÜÁõñÂå∫ÂüüÔºöÂÖ¨Âè∏‰ø°ÊÅØÂå∫Âüü(2.6" √ó 1.5")
      
      // ‰∏ªË¶ÅË¶ÜÁõñÂå∫ÂüüÔºöÂÖ¨Âè∏‰ø°ÊÅØ
      page.drawRectangle({
        x: coverRectX,
        y: coverRectY,
        width: coverRectWidth,
        height: coverRectHeight,
        color: rgb(1, 1, 1), // ÁôΩËâ≤
      });

      // È¢ùÂ§ñË¶ÜÁõñÂå∫ÂüüÔºöÈöêËóè"Pay online"ÈìæÊé•
      // Pay onlineË¶ÜÁõñÂå∫ÂüüÔºöÂÆΩ2.6Ëã±ÂØ∏ÔºåÈ´ò0.3Ëã±ÂØ∏Ôºõ‰ΩçÁΩÆÔºöx:0.23 y:3.46Ëã±ÂØ∏
      const payOnlineLinkX = 0.23 * POINTS_PER_INCH;      // 16.56 ÁÇπ
      const payOnlineLinkY = (11 - 3.46 - 0.3) * POINTS_PER_INCH; // PDF YËΩ¥‰ªéÂ∫ïÈÉ®ÂºÄÂßã: (11 - 3.46 - 0.3) * 72
      const payOnlineLinkWidth = 2.6 * POINTS_PER_INCH;   // 187.2 ÁÇπ  
      const payOnlineLinkHeight = 0.3 * POINTS_PER_INCH;  // 21.6 ÁÇπ
      
      page.drawRectangle({
        x: payOnlineLinkX - 2,
        y: payOnlineLinkY - 2,
        width: payOnlineLinkWidth + 4,
        height: payOnlineLinkHeight + 4,
        color: rgb(1, 1, 1), // ÁôΩËâ≤ÔºåÂÆåÂÖ®Ë¶ÜÁõñÈìæÊé•
      });

      // Pay onlineÈìæÊé•Ë¶ÜÁõñÂÆåÊàê

      // ÊîæÁΩÆÊñ∞ÁöÑÂÖ¨Âè∏‰ø°ÊÅØ - Âú®Ë¶ÜÁõñÂå∫ÂüüÂÜÖÂêàÈÄÇ‰ΩçÁΩÆ
      const fontSize = 9; // ÂåπÈÖçÂéüPDFÁöÑÂ≠ó‰ΩìÂ§ßÂ∞è
      const lineHeight = 12;
      const textX = coverRectX + 10; // Âú®Ë¶ÜÁõñÂå∫ÂüüÂÜÖÔºåÂ∑¶‰æßÁïô10ÁÇπmargin
      
      // ‰ªéË¶ÜÁõñÂå∫ÂüüÈ°∂ÈÉ®ÂºÄÂßãÊîæÁΩÆÊñáÊú¨
      let yPosition = coverRectY + coverRectHeight - 15; // ‰ªéË¶ÜÁõñÂå∫ÂüüÈ°∂ÈÉ®ÂºÄÂßãÔºåÁïô15ÁÇπmargin
      
      // ÂºÄÂßãÊîæÁΩÆÊñ∞ÁöÑÂÖ¨Âè∏‰ø°ÊÅØÊñáÊú¨

      // ÂÖ¨Âè∏ÂêçÁß∞ (Á≤ó‰Ωì)
      const companyNameY = yPosition;
      page.drawText(replacement.newInfo.name, {
        x: textX,
        y: yPosition,
        size: fontSize, // ‰ΩøÁî®Áõ∏ÂêåÂ≠ó‰ΩìÂ§ßÂ∞è
        font: boldFont,
        color: rgb(0, 0, 0),
      });
      yPosition -= lineHeight;
      
      // ÂÖ¨Âè∏ÂêçÁß∞Â∑≤ÊîæÁΩÆ

      // Âú∞ÂùÄ‰ø°ÊÅØ
      for (let i = 0; i < replacement.newInfo.address.length; i++) {
        const addressLine = replacement.newInfo.address[i];
        
        page.drawText(addressLine, {
          x: textX,
          y: yPosition,
          size: fontSize,
          font: font,
          color: rgb(0, 0, 0),
        });
        
        yPosition -= lineHeight;
      }

      // ÂüéÂ∏Ç
      const cityY = yPosition;
      page.drawText(replacement.newInfo.city, {
        x: textX,
        y: yPosition,
        size: fontSize,
        font: font,
        color: rgb(0, 0, 0),
      });
      yPosition -= lineHeight;
      
      // ÂõΩÂÆ∂
      page.drawText(replacement.newInfo.country, {
        x: textX,
        y: yPosition,
        size: fontSize,
        font: font,
        color: rgb(0, 0, 0),
      });

      // ÁîµËØùÂè∑Á†ÅÔºàÂ¶ÇÊûúÊúâÔºâ
      if (replacement.newInfo.phone) {
        yPosition -= lineHeight;
        
        page.drawText(replacement.newInfo.phone, {
          x: textX,
          y: yPosition,
          size: fontSize,
          font: font,
          color: rgb(0, 0, 0),
        });
      }
      
      return { applied: true };
      
    } catch (error) {
      log.error(`üí• Failed to replace company info on page ${pageNumber}`, {
        pageNumber,
        replacement: {
          from: replacement.oldInfo.name,
          to: replacement.newInfo.name
        },
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      });
      
      return { applied: false };
    }
  }

  /**
   * Ëé∑ÂèñÁºìÂ≠òÁöÑPDF URL
   */
  private async getCachedPDF(invoiceId: string): Promise<string | null> {
    try {
      // ÊûÑÂª∫ÁºìÂ≠òÊñá‰ª∂URL
      const cacheKey = `${PDFProcessor.CACHE_PREFIX}${invoiceId}.pdf`;
      const cachedUrl = `${process.env.R2_PUBLIC_URL}/${cacheKey}`;
      
      // Ê£ÄÊü•ÁºìÂ≠ò
      
      // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®ÔºàÁÆÄÂçïÁöÑHEADËØ∑Ê±ÇÔºâ
      const checkStart = Date.now();
      const response = await fetch(cachedUrl, { 
        method: 'HEAD',
        headers: {
          'User-Agent': 'LEGNEXT-PDF-Processor/1.0'
        }
      });
      const checkTime = Date.now() - checkStart;
      
      // ÁºìÂ≠òÊ£ÄÊü•ÂÆåÊàê
      
      if (response.ok) {
        return cachedUrl;
      } else {
        return null;
      }
      
    } catch (error) {
      log.warn(`‚ö†Ô∏è Cache check failed`, {
        invoiceId,
        error: error instanceof Error ? {
          name: error.name,
          message: error.message
        } : error
      });
      return null;
    }
  }

  /**
   * Ê∏ÖÈô§ÁºìÂ≠òÁöÑPDF
   */
  async clearCache(invoiceId: string): Promise<boolean> {
    try {
      const cacheKey = `${PDFProcessor.CACHE_PREFIX}${invoiceId}.pdf`;
      
      log.info(`üóëÔ∏è Starting cache cleanup`, {
        invoiceId,
        cacheKey
      });
      
      // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†R2Âà†Èô§ÈÄªËæë
      // ÁõÆÂâçÁÆÄÂçïËøîÂõûtrueÔºåÂ∞ÜÊù•ÂèØ‰ª•ÈõÜÊàêÂÆûÈôÖÁöÑÂà†Èô§Êìç‰Ωú
      
      log.info(`‚úÖ Cache cleared successfully`, {
        invoiceId,
        cacheKey,
        note: 'Currently using simple cleanup - can be enhanced with actual R2 deletion'
      });
      
      return true;
    } catch (error) {
      log.error(`üí• Cache cleanup failed`, {
        invoiceId,
        error: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      });
      return false;
    }
  }
}

// ÂØºÂá∫ÈªòËÆ§ÂÆû‰æã
export const pdfProcessor = new PDFProcessor();
